\section{Implementations-Sicht}

\subsection{Beispiel: Verarbeitung eines Requests}

Das folgende Sequenzdiagramm zeigt die Verarbeitung eines einfachen HTTP Requests und wie er auf der Serverkomponente gerendert wird.

Views welche Daten aus der API-Komponente anzeigen, stellen während des Aufrufs von \emph{beforeRender()} sicher, dass diese geladen werden. Der schlussendliche Aufruf von \emph{renderView()} übernimmt die eigentliche Ausgabe ins HTML \gls{DOM}.

\begin{figure}[ht!]
	\centering{
		\resizebox{0.9\textwidth}{!} {
			\begin{tikzpicture}
				\begin{umlseqdiag}
					\umlactor[class=Browser]{client}
					\umlobject[class=Barefoot]{barefoot}
					\umlobject[class=Router]{router}
					\umlobject[class=View]{view}
					\umlobject[class=Model]{model}
					\umlobject[class=ApiAdapter]{apiAdapter}
					\umlobject[class=DataStore]{dataStore}

					\begin{umlcall}[op=GET Request, return=HTML]{client}{barefoot}
						\begin{umlcall}[op=route(), with return]{barefoot}{router}
							\begin{umlcallself}[op=render()]{router}
								\begin{umlcallself}[op=initDOM()]{router}
								\end{umlcallself}
								\begin{umlcallself}[op=renderMainView()]{router}
								\end{umlcallself}

								\begin{umlcallself}[op=renderView()]{router}
									\begin{umlcall}[op=beforeRender(), with return]{router}{view}
										\begin{umlcall}[op={fetch()}, return=success()]{view}{model}
											\begin{umlcall}[op={sync()}, return=success()]{model}{apiAdapter}
												\begin{umlcallself}[op={dispatchLocalApiCall()}]{apiAdapter}
												\end{umlcallself}
												\begin{umlcallself}[op={matchRoute()}]{apiAdapter}
												\end{umlcallself}
												\begin{umlcallself}[op={processCallbacks()}]{apiAdapter}
												\end{umlcallself}
											\end{umlcall}
										\end{umlcall}
									\end{umlcall}

									\begin{umlcall}[op=renderView(), return=HTML]{router}{view}
									\end{umlcall}

									\begin{umlcall}[op=afterRender(), with return]{router}{view}
									\end{umlcall}
								\end{umlcallself}

								\begin{umlcall}[op=toJSON(), with return]{router}{dataStore}
								\end{umlcall}

								\begin{umlcallself}[op=writeHTTPResponse()]{router}
								\end{umlcallself}
							\end{umlcallself}
						\end{umlcall}
					\end{umlcall}
				\end{umlseqdiag}
			\end{tikzpicture}
		}
	}
	\caption{Sequenzdiagramm der Verarbeitung eines einfachen Requests}
\end{figure}

\subsection{Quellcode Organisation}
Auch für Applikationen für Node.JS ist üblich (\cite{TJH_ComponentStructure}, \cite{IZS_ComponentStructure}), den Quellcode soweit wie möglich in mehr oder weniger komplett eigenständige Komponenten zu unterteilen.

Ein gutes Beispiel hierfür sind die Vielzahl an verfügbaren Modulen welche über den Komponentenmanager NPM \cite{NPM} installierbar sind. Selbst Bibliotheken mit minimalem Umfang werden und sollten als eigene Module gekappselt werden.

Die Beispielapplikation ``Roomies'' folgt diesem Beispiel: Jede Komponente (Controllers, Policies usw.) ist abgetrennt von der eigentlichen Applikation. Sie werden erst zum Zeitpunkt der eigentlichen Initialisierung der Applikation eingebunden und konfiguriert.\\[0.5mm]

Der folgende Auszug aus der Ordnerstruktur veranschaulicht dieses Prinzip:
\begin{verbatim}
├── src
│   ├── lib
│   │   ├── community
│   │   │   └── views
│   │   │   └── controller.js
│   │   │   └── index.js
│   │   │   └── model.js
│   │   │   └── test.js
│   │   ├── facebook-channel
│   │   │   └── views
│   │   ├── home
│   │   │   └── views
│   │   ├── login
│   │   │   └── views
│   │   ├── middleware
│   │   ├── resident
│   │   │   └── views
│   │   ├── task
│   │   │   └── views
│   │   └── ...
│   ├── shared
│   │   ├── locales
│   │   ├── partials
│   │   ├── policies
│   │   ├── validators
│   │   └── ...
│   └── ...
└── ...
\end{verbatim}

Jede im Verzeichnis \emph{lib} enthaltene Komponente kann mit Node.JS über mittels einem \emph{require} Befehls eingebunden werden.

Dabei muss und sollte keine konkrete JavaScript Datei angegeben werden. Jede Komponente enthält eine \emph{index.js}-Datei, welche die Initialisierung der Komponente, aber auch die Repräsentation ``nach Aussen'' übernimmt.

\begin{lstlisting}[language=JavaScript, caption=Einbindung der Community-Komponenten]
// Requires actually ./lib/community/index.js:
var Community = require('./lib/community');
\end{lstlisting}
