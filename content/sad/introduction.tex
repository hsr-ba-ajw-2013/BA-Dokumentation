\section{Einleitung}

Die Architektur besteht aus den folgenden Elementen:
\begin{itemize}
	\item Eine Backend-Komponente mit \emph{Express.js} \cite{Expressjs}
	%\item Frontend-Applikation mit \emph{Backbone.js} \cite{Backbonejs}
	\item Eine mittels \emph{Sequelize} \cite{Sequelize} abstrahierte
		\emph{PostgreSQL} \cite{PostgreSQL} Datenbank
\end{itemize}


\subsection{Backend-Komponenten}

Der Backend-Teil der Applikation verfügt über eine auf Komponenten-basierte
MVC Architektur. Diese ermöglicht eine optimale Trennung von Zuständigkeiten
\cite{SeparationOfConcerns} und damit eine niedrige Kopplung.

Durch die Verwendung von \emph{Express.js} \cite{Expressjs} ist es einerseits
einfach, die definierten, projektspezifischen Architekturrichtlinien zu
demonstrieren, andererseits ddie Strukturierung der Komponenten selber zu
definieren.

Nach mehreren Experimenten mit verschiedenen Strukturierungen des Quellcodes
stellte sich die von TJ Holowaychuck (Lead Entwickler von \emph{Express.js}
\cite{TJH}) vorgestellte Komponentenaufteilung  \cite{TJH_ComponentStructure}
als am geeignetsten heraus.

% TODO: Add if done
% Um das Prinzip ``\gls{DRY}'' zu erfüllen, werden Controllers und Templates
% mit dem Frontend geteilt.

% \subsection{Frontend-Applikation}

% Die Frontend-Applikation ist ebenfalls MVC-basiert und holt die entsprechende
% Logik vom geteilten Backend-Code.
% Im Optimalfall (Der Client-Browser hat JavaScript aktiviert) wird das Backend
% nur für die Datenübertragung angesprochen.
% Alles andere passiert direkt im Browser des Clients.
% Für Suchmaschinen und Browsern mit JavaScript deaktiviert, funktioniert die
% Applikation aber ohne jegliche Probleme.

\subsection{Datenbank und ORM}

Das schlanke JavaScript \gls{ORM} \emph{Sequelize} \cite{Sequelize} setzt auf
der quelloffenen Datenbank \emph{PostgreSQL} \cite{PostgreSQL}.