\section{RP1 REST}
\label{sec:principle-rp1-rest}

\gls{REST} beschreibt einen API-Stil welcher grundlegende Auswirkungen auf die Architektur einer komplexen Client-Server Software hat und durch mehrere Randbedingungen gegeben ist:
\begin{itemize}
	\item Kommunikation zwischen Client und Server ist zustandslos
	\item HTTP wird als Grundlage verwendet
	\item \glspl{URI} sind Identifikatoren für Ressourcen auf dem Server
	\item Daten-Serialisierung (XML, JSON, etc.) ist nicht vorgegeben
\end{itemize}

Durch die Bedingung der Zustandlosigkeit wird durch Einsatz dieser Architektur ermöglicht, skalierbare Schnittstellen zur Verfügung zu stellen.

Eine weitere Implementationstechnik von REST-APIs ist die Versionierung. Diese ermöglicht es Client und Server unabhängig voneinander weiter zu entwickeln.
Sobald die API eine neue Version erstellt und Rückwärtskompatibilität mit den alten Versionen garantiert, kann die Client-Software weiterentwickelt werden.

REST liegt HTTP zugrunde. Es werden explizit die sogenannten HTTP-Verben (GET, POST, PUT, DELETE etc.) verwendet um Ressourcen abzufragen oder zu manipulieren.
Durch den Einsatz des HTTP-Standards wird Caching auch direkt ermöglicht. Voraussetzung dafür ist, dass die Software die entsprechenden Caching-Headers in den Antworten sendet.

Damit spezifische Instanzen einer Ressourcen ansprechbar sind, ist die Verwendung korrekter und eindeutiger \glspl{URI} Pflicht. Jeder Objekt-Typ und jedes Objekt sollte eindeutig identifizierbar sein.

Der Datentyp mit welchem Objekte und Collections übertragen werden ist hingegen nicht definiert. Dem Software Entwickler ist die Serialisierung der Daten somit selber überlassen.
Vielfach wird heute jedoch \gls{JSON} eingesetzt, da es eine kompakte und doch gut lesbare Serialisierungsform ist.


\subsection*{Geplante Umsetzung}
Die Beispielapplikation \emph{Roomies} soll REST mit JSON als Datentyp für seine API verwenden

Jede Ressource welche über die Website angefragt werden kann, soll auch über die REST-API verfügbar sein. Um den Sourcecode möglichst schlank halten zu können, soll auch intern die API verwendet werden.
Somit ist die API zwingend entkoppelt vom sonstigen Quelltext.

Eine Versionierung und das Caching der API-Zugriffe ist nicht geplant. Dies wurde vorallem aus Zeitgründen so entschieden.
Eine Versionierung wäre jedoch durch ein zusätzliches Präfix für die API-Route ohne Probleme lösbar.
Das selbe gilt für das Caching. Jedes Objekt in der Datenbank hat eine Spalte mit der Information, wann dieser Datensatz zuletzt modifiziert wurde. Durch diese Information kann generisch an einem Punkt ein Caching implementiert werden.

\subsection*{Konkrete Umsetzung}
Die API der Beispielapplikation ist als separater Service-Layer implementiert worden. Auf diese wurd client- als auch serverseitig transparent zugegriffen.

Das Beispiel im Quelltext \ref{lst:restApiRoomies} zeigt zwei Definitionen einer solchen Route in der API.

\begin{lstlisting}[language=JavaScript, caption=Community API Definition \cite{communityApiDefinition}, label=lst:restApiRoomies, firstnumber=23, escapeinside={@}{@}]
var controller = require('./controller')
	, basicAuthentication = require('../policy/basicAuthentication')
	, authorizedForCommunity = require('../policy/authorizedForCommunity')
	, communityValidators = require('./validators')
	, utils = require('../utils')
	, modulePrefix = '/community';

module.exports = function initCommunityApi(api, apiPrefix) {
	var prefix = apiPrefix + modulePrefix;

	// GET /api/community/:id
	@\label{lst:restApiRoomies_get}@api.get(prefix + '/:id(\\d+)', [
		basicAuthentication
		, authorizedForCommunity
		, controller.getCommunityWithId]);

	// GET /api/community/:slug
	api.get(prefix + '/:slug', [
		basicAuthentication
		, authorizedForCommunity
		, controller.getCommunityWithSlug]);

	// POST /api/community
	@\label{lst:restApiRoomies_post}@api.post(prefix, [
		basicAuthentication
		, communityValidators.createCommunity
		, controller.createCommunity
	]);
	//...
};
\end{lstlisting}

Bei Zeile \autoref{lst:restApiRoomies_get} wird eine ``GET'' API für das Abfragen einer WG mit der \emph{ID} definiert. Wie man im definierten Array sieht, werden dabei mehrere Callbacks definiert, welche der Reihe nach aufgerufen werden und sicherstellen, dass jede Anfrage authentifiziert und authorisiert ist.

Zeile \autoref{lst:restApiRoomies_post} definiert eine ``POST'' Route um eine neue Community zu erstellen. Auch hier wird überprüft ob der Benutzer authentifiziert ist. Zudem wird auch ein Daten-Validator definiert, damit sichergestellt werden kann dass die Daten korrekt und ohne unerwünschte Zeichen sind.

\subsection*{Diskussion}

REST ist eine immer wichtigere Architekturform und wird in dieser Form überall eingesetzt. Es definiert die wichtigsten Grundbedürfnisse und überlässt applikationsspezifische Entscheidungen dem Software Entwickler.

Seit einiger Zeit ist es immer wichtiger eine generische Schnittstelle auch für kleinere Websiten zu erstellen. Vielfach wird seit dem aufkommen von Smartphones nicht nur eine Website erstellt, sondern auch entsprechende Apps für Mobiltelefone.

Dadurch dass REST auch keine Serialisierungsform benutzt, ist es dem Entwickler der API möglich, verschiedene Datenformate zu unterstützen (siehe auch \ref{sec:principle-rp6-should-formats} ``\nameref{sec:principle-rp6-should-formats}''). Dies ermöglicht beispielsweise die Nutzung eines kompakten Datenformats für Mobiltelefone, damit die Datenrechnung nicht strapaziert wird.

Durch die relativ flexible REST-Definition mit einigen wenigen Randbedingungen tut sich aber auch ein wichtiger Diskussionspunkt auf: Mit welchem HTTP-Verb (POST oder PUT) werden Updates gehandhabt? Es gibt hier verschiedene Ansichten und die Diskussion ist bei weitem nicht abgeschlossen. Eine gute Hilfestellung hierfür bietet ``Stack Overflow - HTTP PUT vs POST in REST'' \cite{StackoverflowPUTvsPOST}.

Abschliessend gibt das Projektteam folgenden Rat: Wenn es nötig ist eine flexible und generische API zu erstellen, ist REST eine sehr gute Lösung. Es erlaubt Entwicklern bestehendes Know-How über das Web wiederzuverwenden und ist skalierbar.